{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import type { IncomingMessage } from 'node:http'\nimport { forwarded } from '@tinyhttp/forwarded'\nimport ipaddr, { type IPv6, type IPv4 } from 'ipaddr.js'\n\ntype Req = Pick<IncomingMessage, 'headers' | 'socket'>\n\nexport type TrustParameter = string | number | string[]\nexport type TrustFunction = (addr: string, i: number) => boolean\nexport type Trust = TrustFunction | TrustParameter\n\ntype Subnet = {\n  ip: IPv4 | IPv6\n  range: number\n}\n\nconst DIGIT_REGEXP = /^[0-9]+$/\nconst isip = ipaddr.isValid\nconst parseip = ipaddr.parse\n/**\n * Pre-defined IP ranges.\n */\nconst IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Type-guard to determine whether a string value represents a pre-defined IP range.\n *\n * @param val\n */\nfunction isIPRangeName(val: string): val is keyof typeof IP_RANGES {\n  return Object.prototype.hasOwnProperty.call(IP_RANGES, val)\n}\n/**\n * Type-guard to determine whether an IP address is a v4 address.\n * @param val\n */\nconst isIPv4 = (val: IPv4 | IPv6): val is IPv4 => val.kind() === 'ipv4'\n/**\n * Type-guard to determine whether an IP address is a v6 address.\n * @param val\n */\nconst isIPv6 = (val: IPv4 | IPv6): val is IPv6 => val.kind() === 'ipv6'\n/**\n * Static trust function to trust nothing.\n */\nconst trustNone = () => false\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param req\n * @param trust\n */\nfunction alladdrs(req: Req, trust?: Trust): string[] {\n  // get addresses\n\n  const addrs = forwarded(req)\n\n  if (trust == null) return addrs\n\n  if (typeof trust !== 'function') trust = compile(trust)\n\n  for (let i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n    addrs.length = i + 1\n  }\n  return addrs\n}\n/**\n * Compile argument into trust function.\n *\n * @param  val\n */\nfunction compile(val: string | number | string[]): (addr: string, i: number) => boolean {\n  let trust: string[]\n  if (typeof val === 'string') trust = [val]\n  else if (typeof val === 'number') return compileHopsTrust(val)\n  else if (Array.isArray(val)) trust = val.slice()\n  else throw new TypeError('unsupported trust argument')\n\n  for (let i = 0; i < trust.length; i++) {\n    const element = trust[i]\n    if (!isIPRangeName(element)) continue\n\n    // Splice in pre-defined range\n    const namedRange = IP_RANGES[element]\n    trust.splice(i, 1, ...namedRange)\n    i += namedRange.length - 1\n  }\n  return compileTrust(compileRangeSubnets(trust))\n}\n/**\n * Compile 'hops' number into trust function.\n *\n * @param hops\n */\nfunction compileHopsTrust(hops: number): (_: string, i: number) => boolean {\n  return (_, i) => i < hops\n}\n\n/**\n * Compile `arr` elements into range subnets.\n */\nfunction compileRangeSubnets(arr: string[]) {\n  return arr.map((ip) => parseIPNotation(ip))\n}\n/**\n * Compile range subnet array into trust function.\n *\n * @param rangeSubnets\n */\nfunction compileTrust(rangeSubnets: Subnet[]) {\n  // Return optimized function based on length\n  const len = rangeSubnets.length\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets)\n}\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\nexport function parseIPNotation(note: string): Subnet {\n  const pos = note.lastIndexOf('/')\n  const str = pos !== -1 ? note.substring(0, pos) : note\n\n  if (!isip(str)) throw new TypeError(`invalid IP address: ${str}`)\n\n  let ip = parseip(str)\n  const max = ip.kind() === 'ipv6' ? 128 : 32\n\n  if (pos === -1) {\n    if (isIPv6(ip) && ip.isIPv4MappedAddress()) ip = ip.toIPv4Address()\n    return { ip, range: max }\n  }\n\n  const rangeString = note.substring(pos + 1, note.length)\n  let range: number | null = null\n\n  if (DIGIT_REGEXP.test(rangeString)) range = Number.parseInt(rangeString, 10)\n  else if (ip.kind() === 'ipv4' && isip(rangeString)) range = parseNetmask(rangeString)\n\n  if (range == null || range <= 0 || range > max) throw new TypeError(`invalid range on address: ${note}`)\n  return { ip, range }\n}\n/**\n * Parse netmask string into CIDR range.\n *\n * @param netmask\n * @private\n */\nfunction parseNetmask(netmask: string) {\n  const ip = parseip(netmask)\n  return ip.kind() === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null\n}\n/**\n * Determine address of proxied request.\n *\n * @param req\n * @param trust\n * @public\n */\nexport function proxyaddr(req: Req, trust: Trust): string {\n  const addrs = alladdrs(req, trust)\n\n  return addrs[addrs.length - 1]\n}\n\n/**\n * Compile trust function for multiple subnets.\n */\nfunction trustMulti(subnets: Subnet[]) {\n  return function trust(addr: string) {\n    if (!isip(addr)) return false\n    const ip = parseip(addr)\n    let ipconv: IPv4 | IPv6 | null = null\n    const kind = ip.kind()\n    for (let i = 0; i < subnets.length; i++) {\n      const subnet = subnets[i]\n      const subnetKind = subnet.ip.kind()\n      let trusted = ip\n      if (kind !== subnetKind) {\n        if (isIPv6(ip) && !ip.isIPv4MappedAddress()) continue\n\n        if (!ipconv) ipconv = isIPv4(ip) ? ip.toIPv4MappedAddress() : ip.toIPv4Address()\n\n        trusted = ipconv\n      }\n      if (trusted.match(subnet.ip, subnet.range)) return true\n    }\n    return false\n  }\n}\n/**\n * Compile trust function for single subnet.\n *\n * @param subnet\n */\nfunction trustSingle(subnet: Subnet) {\n  const subnetKind = subnet.ip.kind()\n  const subnetIsIPv4 = subnetKind === 'ipv4'\n  return function trust(addr: string) {\n    if (!isip(addr)) return false\n    let ip = parseip(addr)\n    const kind = ip.kind()\n    if (kind !== subnetKind) {\n      if (subnetIsIPv4 && !(ip as IPv6).isIPv4MappedAddress()) return false\n\n      ip = subnetIsIPv4 ? (ip as IPv6).toIPv4Address() : (ip as IPv4).toIPv4MappedAddress()\n    }\n    return (ip as IPv6).match(subnet.ip, subnet.range)\n  }\n}\n\nexport { alladdrs as all }\nexport { compile }\n"],"names":[],"mappings":"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"}